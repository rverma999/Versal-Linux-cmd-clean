// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
// *****************************************************************************
// File: io_buffer_compiler.h
// 
/// This file contains the definition of the _io_buffer_class which is used
/// only in code generated by aiecompiler such as the core programs C_R.cc
/// and the PthreadSim.cpp simulator code.
// *****************************************************************************
#ifndef _IO_BUFFER_SRC_IO_BUFFER_COMPILER_H_
#define _IO_BUFFER_SRC_IO_BUFFER_COMPILER_H_

#include "detail/io_buffer_util.h"

namespace adf {

template<typename tpValueTy,
         typename tpDirection,
         typename tpConfig>
class _io_buffer: public io_buffer<tpValueTy, tpDirection, tpConfig>
{
public:
    using value_type = tpValueTy;
    using config_type = tpConfig;
    using base_type = io_buffer<tpValueTy, tpDirection, config_type>;
    using user_port_type = base_type;

#ifndef __X86SIM__
    template<typename tpLockingMode2 = typename config_type::locking_mode,
             typename ... tpSizes >
    inline _io_buffer
    (std::enable_if_t<std::is_same_v<tpLockingMode2, locking::sync>,
                      value_type> *data0,
                        uint32_t    size,
                        uint32_t    margin,
                        tpSizes ... sizes)
        :   base_type(data0, size, margin, sizes...)
    {
    }

    template<typename tpLockingMode2 = typename config_type::locking_mode,
             typename ... tpSizes >
    inline _io_buffer
    (std::enable_if_t<std::is_same_v<tpLockingMode2, locking::async>,
                      value_type> *data0,
                        unsigned    lockId0,
                        value_type *data1,
                        unsigned    lockId1,
                        uint32_t    size,
                        uint32_t    margin,
                        tpSizes ... sizes)
        :   base_type ( data0, lockId0, data1, lockId1, size, margin, sizes ...)
    {
    }
#else
    template<typename tpLockingMode2 = typename config_type::locking_mode,
             typename ... tpSizes >
    inline _io_buffer
    (std::enable_if_t<std::is_same_v<tpLockingMode2, locking::sync>,
                      uint32_t>    size,
     uint32_t    margin,
     tpSizes ... sizes)
        :   base_type(nullptr, size, margin, sizes...),
            _iCurrentBufId { 0 },
            _iBuf { },
            _iMargin { detail::numElem_to_sizeInBytes<value_type>(margin) }
    {
    }

    template<typename tpLockingMode2 = typename config_type::locking_mode,
             typename ... tpSizes >
    inline _io_buffer
    (std::enable_if_t<std::is_same_v<tpLockingMode2, locking::async>,
                      uint32_t>    size,
                        uint32_t    margin,
                        tpSizes ... sizes)
        :   base_type ( nullptr, -1, nullptr, -1, size, margin, sizes ...),
            _iCurrentBufId { 0 },
            _iBuf { },
            _iMargin { detail::numElem_to_sizeInBytes<value_type>(margin) }

    {
    }
#endif
    

#ifndef __X86SIM__
    //XXX Remove first argument.
    static inline void acquire(_io_buffer &port,
                               unsigned lockId0,
                               unsigned lockId1,
                               int bufId)
    {
#if defined(__LOCK_FENCE_MODE__) && __LOCK_FENCE_MODE__==2
        if constexpr (config_type::_margin == 0)
        {
            base_type::acquire_(port.base(), lockId0, lockId1, bufId);
        }
        else
        {
            base_type::acquire_(lockId0, lockId1, bufId);
        }
#elif defined(__LOCK_FENCE_MODE__) && __LOCK_FENCE_MODE__==3
        base_type::acquire_(port.base(), lockId0, lockId1, bufId);
#else
        base_type::acquire_(lockId0, lockId1, bufId);
#endif
    }
    
    //XXX Remove first argument.
    static inline void release(_io_buffer &port,
                               unsigned lockId0,
                               unsigned lockId1,
                               int bufId)
    {
#if defined(__LOCK_FENCE_MODE__) && __LOCK_FENCE_MODE__==2
        if constexpr (config_type::_margin == 0)
        {
            base_type::release_(port.base(), lockId0, lockId1, bufId);
        }
        else
        {
            base_type::release_(lockId0, lockId1, bufId);
        }
#elif defined(__LOCK_FENCE_MODE__) && __LOCK_FENCE_MODE__==3
        base_type::release_(port.base(), lockId0, lockId1, bufId);
#else
        base_type::release_(lockId0, lockId1, bufId);
#endif
    }

    static inline void advanceHead(_io_buffer &port,
                                   int delta,
                                   unsigned totalSize)
    {
        if constexpr (tpConfig::_margin != 0)
        {
#if defined(__AIENGINE__)
            port._head = (_io_buffer::value_type *)
                cyclic_add((int8_t*) port._head, 
                           detail::numElem_to_sizeInBytes
                           <_io_buffer::value_type>(delta),
                           (int8_t*) port._base, 
                           detail::numElem_to_sizeInBytes
                           <_io_buffer::value_type>(totalSize));
#else
            port._head += delta;
            if (port._head < port._base)
                port._head += totalSize;
            if (port._head >= (port._base + totalSize))
                port._head -= totalSize;
#endif
        }
    }
    
    // If bufid = 0: copy top portion of buf0 into margin portion of buf1.
    static inline void marginCopy(value_type *buf0,
                                  value_type *buf1,
                                  int bufId,
                                  unsigned size,
                                  unsigned margin)
    {
        detail::bufferPortMarginCopy((bufId ? buf0: buf1), (bufId ? buf1: buf0),
                                     size, margin);
    }

    // Set base address and optionally set head.
    static inline void setData(_io_buffer &port,
                               value_type *buf0,
                               value_type *buf1,
                               int bufId,
                               unsigned margin)
    {
        if constexpr (tpConfig::_margin == 0)
        {
            port._base = bufId ? detail::addMargin(buf1, margin):
                                 detail::addMargin(buf0, margin);
        }
        else
        {
            port._base = bufId ? buf1: buf0;
            if constexpr (std::is_same_v<tpDirection,direction::out>)
                port._head = bufId ? detail::addMargin(buf1, margin): 
                                     detail::addMargin(buf0, margin);
            else
                port._head = bufId ? buf1: buf0;
        }
    }

    // if lockless
    //     assert 1 buffer
    //     if zero margin => no changes needed
    //     else
    //         if revolving margin
    //             increment head by window size in postRelease
    //         else
    //             margin copy in pre-release for input port
    // with lock
    //     if 1 buffer: no changes needed
    //     if 2 buffers:
    //         preAcquire sets data and head
    //         prerelase copies margin for input port
    static inline void acquireActions(_io_buffer &port,
                                      value_type *buf0,
                                      unsigned lock0,
                                      value_type *buf1,
                                      unsigned lock1,
                                      int bufId,
                                      unsigned margin,
                                      bool avoidMarginCopy)
    {
        if (lock0 != -1)
        {
            if (buf0 != buf1)
            {
                setData(port, buf0, buf1, bufId, margin);
            }
            acquire(port, lock0, lock1, bufId);
        }
    }

    static inline void releaseActions(_io_buffer &port,
                                      value_type *buf0,
                                      unsigned lock0,
                                      value_type *buf1,
                                      unsigned lock1,
                                      int bufId,
                                      unsigned size,
                                      unsigned margin,
                                      bool avoidMarginCopy)
    {
        if (lock0 != -1)
        {
            if constexpr (std::is_same_v<tpDirection,direction::in>) {
                if (margin)
                    marginCopy(buf0, buf1, bufId, size, margin);
            }
            release(port, lock0, lock1, bufId);
        }
        else
        {
            // lock less; only 1 buffer.
            if (avoidMarginCopy)
                advanceHead(port, size, size + margin);
            else
                if constexpr (std::is_same_v<tpDirection,direction::in>)
                    marginCopy(buf0, buf0, 0, size, margin);
        }
    }

#else // ifndef __X86SIM__
    // X86SIM flow does not use the _acquireRelease!
    using internal_datatype = io_buffer_internal::internal_datatype;
    virtual void _iInit(x86sim::IWindowConnector *conn,
                        internal_datatype *buf0,
                        internal_datatype *buf1) override
    {
        this->_iConn = conn;
        _iBuf[0] = buf0;
        _iBuf[1] = buf1;
        _iCurrentBufId = 0;
        this->_base = (tpValueTy*)buf0;
        _iSetHead();
        //XXX X86SIM flow does not use _heads[2].
    }
    void _iSetHead() override
    {
        if constexpr (tpConfig::_margin != 0)
        {
            this->_head = (tpValueTy*) _iBuf[_iCurrentBufId];
            if (_iMargin > 0 && std::is_same_v<tpDirection,direction::out>)
            {
                if (detail::is_4_bit_type<tpValueTy>::value)
                {
                    this->_head += 
                        detail::sizeInBytes_to_numElem<tpValueTy>(_iMargin)/2;
                }
                else
                {
                    this->_head += 
                        detail::sizeInBytes_to_numElem<tpValueTy>(_iMargin);
                }
            }
        }
    }
    internal_datatype *_iData() const override
    {
        return (internal_datatype*) this->_base;
    }
    void _iSetData() override
    {
        this->_base = ((value_type*)_iBuf[_iCurrentBufId]);
    }
    void *_iGetBuf(unsigned id) const override
    {
        return _iBuf[id];
    }
    unsigned _iGetCurrentBufId() const override
    {
        return _iCurrentBufId;
    }
    void _iToggleCurrentBufId() override
    {
        _iCurrentBufId = 1 - _iCurrentBufId;
    }
    uint32_t _iGetSize() const override
    {
        return detail::numElem_to_sizeInBytes<value_type>(this->size());
    }
    uint32_t _iGetSizeInclMargin() const override
    {
        return detail::numElem_to_sizeInBytes<value_type>(
                   this->size_incl_margin());
    }
    void _iMarginCopy() override
    {
        internal_datatype *src = _iBuf[_iCurrentBufId];
        internal_datatype *dst = _iBuf[1 - _iCurrentBufId];
        memcpy(dst, src + _iGetSize(), _iMargin);
    }
private:
    unsigned            _iCurrentBufId;
    internal_datatype  *_iBuf[2];
    // Margin in bytes
    unsigned            _iMargin;
#endif  // ifdef __X86SIM__
};

//******************************************************************************
// io_buffer_bypass_copy
//
/// Copy content of source to dest. Used for bypass.
//******************************************************************************
#ifdef __AIENGINE__
template<typename tpSourcePort,
         typename tpDestPort>
inline void io_buffer_bypass_copy(tpSourcePort &__restrict source,
                                    tpDestPort & __restrict  dest,
                                    uint32_t                 size)
{
    v8int32 * restrict sourceData = (v8int32 * restrict) source.data();
    v8int32 * restrict destData = (v8int32 * restrict) dest.data();

    unsigned num = size / sizeof(v8int32);
    for (unsigned int ind = 0; ind < num; ++ind)
        *destData++ = *sourceData++;

    //XXX window_bypass_copy assumes that window size is multiple of 32!
    if (num * sizeof(v8int32) < size)
    {
        int32 *sourcePtr = (int32*) sourceData;
        int32 *destPtr = (int32*) destData;
        num = (size - num * sizeof(v8int32)) >> 2;
        for (unsigned ind = 0; ind < num; ++ind)
            *destPtr++ = *sourcePtr++;
    }
}
#endif

template<typename tpValueTy,
         typename tpDirection,
         typename tpConfig,
         typename tpEnable=void>
class _io_buffer_ml;

//******************************************************************************
/// This is the class used by aiecompiler in the generated R_C.cc for the
/// multi-layer aie_ml flow. This 
//******************************************************************************
template<typename tpValueTy,
         typename tpDirection,
         typename tpConfig>
class _io_buffer_ml<tpValueTy, tpDirection, tpConfig,
                       std::enable_if_t<std::is_same_v<typename tpConfig::locking_mode, locking::sync>>>
    : public _io_buffer<tpValueTy, tpDirection, tpConfig>
{
public:
    using value_type = tpValueTy;
    using config_type = tpConfig;
    using base_type = _io_buffer<tpValueTy, tpDirection, config_type>;

    template<typename ... tpSizes >
    inline _io_buffer_ml(value_type *data0,
                           uint32_t size,
                           uint32_t margin,
                           tpSizes ... sizes)
        :base_type( data0, size, margin, sizes...),
         _currentBufId { 0 }
    {
    }

    inline void acquire(value_type *buf0,
                        unsigned lock0,
                        value_type *buf1,
                        unsigned lock1,
                        unsigned margin,
                        bool avoidMarginCopy)
    {
        base_type::acquireActions(*this, buf0, lock0, buf1, lock1,
                                  _currentBufId, margin, avoidMarginCopy);
    }

    inline void release(value_type *buf0,
                        unsigned lock0,
                        value_type *buf1,
                        unsigned lock1,
                        unsigned size,
                        unsigned margin,
                        bool avoidMarginCopy)
    {
        base_type::releaseActions(*this, buf0, lock0, buf1, lock1,
                                  _currentBufId, size, margin, avoidMarginCopy);
        _currentBufId = 1 - _currentBufId;
    }
private:
    uint32_t                      _currentBufId;
};

} // namespace adf

#endif // ifndef_IO_BUFFER_SRC_IO_BUFFER_COMPILER_H_
